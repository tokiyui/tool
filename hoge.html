<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>Copernicus SWH (netCDF4 via PyScript)</title>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- PyScript -->
<link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css">
<script defer src="https://pyscript.net/latest/pyscript.js"></script>

<style>
html, body, #map {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
}
#status {
  position: absolute;
  top: 6px;
  left: 6px;
  background: rgba(255,255,255,0.9);
  padding: 6px;
  font-family: monospace;
  z-index: 999;
}
</style>
</head>
<body>

<div id="map"></div>
<div id="status">initializing…</div>

<py-config>
packages = [
  "numpy",
  "netCDF4",
  "pillow"
]
</py-config>

<py-script>
import numpy as np
from netCDF4 import Dataset
from PIL import Image
import datetime
import io
import urllib.request
import js
import asyncio

# ============================
# 最新時刻計算
# ============================
def latest_base_time():
    now = datetime.datetime.utcnow() - datetime.timedelta(hours=6)
    hour = (now.hour // 3) * 3
    return now.replace(hour=hour, minute=0, second=0, microsecond=0)

def fmt(t):
    return t.strftime("%Y%m%dT%H0000")

# ============================
# URL生成
# ============================
def build_url():
    t1 = latest_base_time()
    t2 = t1 + datetime.timedelta(hours=3)
    t3 = datetime.datetime.utcnow()

    y = t1.year
    m = f"{t1.month:02d}"

    filename = (
        f"cmems_obs-wave_glo_phy-swh_nrt_cfo-l3_PT1S_202211_"
        f"{fmt(t1)}_{fmt(t2)}_{fmt(t3)}.nc"
    )

    return (
        "https://data.marine.copernicus.eu/product/"
        "WAVE_GLO_PHY_SWH_L3_NRT_014_001/files"
        f"?path=WAVE_GLO_PHY_SWH_L3_NRT_014_001/"
        f"cmems_obs-wave_glo_phy-swh_nrt_cfo-l3_PT1S_202211/"
        f"{y}/{m}/"
        f"&subdataset={filename}"
    )

# ============================
# メイン処理
# ============================
async def main():
    js.document.getElementById("status").innerText = "fetching netCDF…"

    url = build_url()
    raw = urllib.request.urlopen(url).read()

    ds = Dataset("mem", memory=raw)

    lon = ds.variables["longitude"][:]
    lat = ds.variables["latitude"][:]
    swh = ds.variables["VAVH"][:]

    ny, nx = swh.shape

    img = Image.new("RGBA", (nx, ny))
    px = img.load()

    # ---- カラールール（観測点と整合） ----
    for j in range(ny):
        for i in range(nx):
            v = swh[j, i]
            if np.isnan(v):
                px[i, ny-1-j] = (0, 0, 0, 0)
            elif v < 1.0:
                px[i, ny-1-j] = (0, 120, 255, 160)
            elif v < 2.0:
                px[i, ny-1-j] = (0, 200, 0, 160)
            elif v < 3.0:
                px[i, ny-1-j] = (255, 200, 0, 160)
            else:
                px[i, ny-1-j] = (255, 0, 0, 160)

    buf = io.BytesIO()
    img.save(buf, format="PNG")
    png = buf.getvalue()

    js.renderOverlay(
        png,
        float(lat.min()), float(lat.max()),
        float(lon.min()), float(lon.max())
    )

    js.document.getElementById("status").innerText = "done"

asyncio.ensure_future(main())
</py-script>

<script>
const map = L.map("map").setView([30, 140], 3);

L.tileLayer(
  "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
  { attribution: "&copy; OpenStreetMap" }
).addTo(map);

window.renderOverlay = function(pngBytes, latMin, latMax, lonMin, lonMax) {
  const blob = new Blob([pngBytes], { type: "image/png" });
  const url = URL.createObjectURL(blob);

  L.imageOverlay(
    url,
    [[latMin, lonMin], [latMax, lonMax]],
    { opacity: 0.7 }
  ).addTo(map);
};
</script>

</body>
</html>
