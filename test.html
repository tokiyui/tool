<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="UTF-8">
<title>高層気温 観測値と平年値（UTC/JST対応）</title>
<style>
body { font-family: sans-serif; }
table { border-collapse: collapse; margin-top: 1em; }
th, td { border: 1px solid #666; padding: 4px 8px; text-align: right; }
th { background: #eee; }
caption { text-align: left; font-weight: bold; }
</style>
</head>
<body>
<h2>高層気温：観測値（Wyoming, UTC） vs 平年値（気象庁, JST）</h2>

<div>
  日時 (UTC): <input id="datetime" value="2023-01-24 12:00" readonly>
  地点番号: <input id="stn" value="47646" readonly>
  <button onclick="loadData()">取得</button>
</div>

<table id="result">
<caption>300 / 500 / 700 / 850 / 925 hPa</caption>
<thead>
<tr>
  <th>気圧(hPa)</th>
  <th>観測値(℃)<br>(UTC)</th>
  <th>平年値(℃)<br>(JST)</th>
  <th>差<br>(観測−平年)</th>
</tr>
</thead>
<tbody></tbody>
</table>

<script>
const TARGET_LEVELS = [300, 500, 700, 850, 925];
const proxy = "https://worker.ryohorita105.workers.dev/?url=";

async function loadData() {
  const dt = document.getElementById('datetime').value;
  const stn = document.getElementById('stn').value;

  const yyyy = dt.slice(0,4);
  const mm = dt.slice(5,7);
  const dd = dt.slice(8,10);
  const hh = dt.slice(11,13);

  // ---- 平年値は JST 基準（UTC+9） ----
  const jstDate = new Date(Date.UTC(yyyy, mm-1, dd, hh));
  jstDate.setUTCHours(jstDate.getUTCHours() + 9);
  const jstMonth = jstDate.getUTCMonth() + 1;
  const jstHour  = jstDate.getUTCHours();

  const obsUrlRaw = `https://weather.uwyo.edu/wsgi/sounding?datetime=${yyyy}-${mm}-${dd}%20${hh}:00:00&id=${stn}&src=FM35&type=TEXT:LIST`;
  const nmlUrlRaw = `https://www.data.jma.go.jp/stats/etrn/upper/view/nml_snd_d.php?month=${jstMonth}&hour=${jstHour}&point=${stn}`;

  const obsUrl = proxy + encodeURIComponent(obsUrlRaw);
  const nmlUrl = proxy + encodeURIComponent(nmlUrlRaw);

  const [obsText, nmlText] = await Promise.all([
    fetch(obsUrl).then(r=>r.text()),
    fetch(nmlUrl).then(r=>r.text())
  ]);

  const obs = parseWyoming(obsText);
  const nml = parseJMA(nmlText, dd);

  const tbody = document.querySelector('#result tbody');
  tbody.innerHTML = '';

  for (const p of TARGET_LEVELS) {
    const obsV = obs[p];
    const nmlV = nml[p];
    const diff = (obsV != null && nmlV != null) ? (obsV - nmlV).toFixed(1) : '';

    const tr = document.createElement('tr');
    tr.innerHTML = `<th>${p}</th>`+
      `<td>${obsV ?? ''}</td>`+
      `<td>${nmlV ?? ''}</td>`+
      `<td>${diff}</td>`;
    tbody.appendChild(tr);
  }
}

function parseWyoming(text) {
  const map = {};
  const lines = text.split('\n');
  for (const line of lines) {
    if (/^\s*\d+\.\d/.test(line)) {
      const cols = line.trim().split(/\s+/);
      const p = Math.round(parseFloat(cols[0]));
      const t = parseFloat(cols[2]);
      if (TARGET_LEVELS.includes(p) && !isNaN(t)) {
        map[p] = t;
      }
    }
  }
  return map;
}

function parseJMA(html, day) {
  const map = {};
  const doc = new DOMParser().parseFromString(html, 'text/html');
  const table = doc.querySelector('#tablefix1');
  if (!table) return map;

  const headerRow = table.querySelectorAll('tr')[1];
  const headers = Array.from(headerRow.querySelectorAll('th')).map(th=>th.textContent);
  const dayRow = Array.from(table.querySelectorAll('tr'))
    .find(tr => tr.firstElementChild?.textContent.trim() === String(parseInt(day)));

  if (!dayRow) return map;

  const tds = dayRow.querySelectorAll('td');
  headers.forEach((h, i)=>{
    const m = h.match(/(\d+)hPa/);
    if (m) {
      const p = parseInt(m[1]);
      if (TARGET_LEVELS.includes(p)) {
        const v = tds[i-1]?.textContent.trim();
        if (v && v !== '///') map[p] = parseFloat(v);
      }
    }
  });
  return map;
}
</script>

</body>
</html>
