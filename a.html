<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>AMeDAS 関東 + 雨雲ナウキャスト</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
html,body { margin:0; height:100%; }
#map { width:100%; height:100%; }

.ctrl {
  position:absolute;
  top:10px; left:10px;
  z-index:1000;
  background:#fff;
  padding:8px;
  font-size:14px;
}

.valbox {
  padding:2px 4px;
  border-radius:4px;
  border:1px solid #000;
  font-weight:bold;
  font-size:12px;
}
</style>
</head>
<body>

<div id="map"></div>

<div class="ctrl">
<label><input type="radio" name="elem" value="temp" checked> 気温</label><br>
<label><input type="radio" name="elem" value="tw"> 湿球温度</label><br>
<label><input type="radio" name="elem" value="td"> 露点温度</label><br>
<label><input type="radio" name="elem" value="rh"> 湿度</label>
</div>

<script>
// ==========================
// 設定
// ==========================
const KANTO = {
  latMin:34.5, latMax:37.5,
  lonMin:138.5, lonMax:141.5
};

let DispElem = "temp";
let rainLayer = null;

// ==========================
// 地図
// ==========================
const map = L.map("map").setView([36.1,139.8],7);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);
const layer = L.layerGroup().addTo(map);

// ==========================
// 計算
// ==========================
function calcTd(T,RH){
  if(isNaN(T)||isNaN(RH)) return NaN;
  const a=17.27,b=237.7;
  const α=(a*T)/(b+T)+Math.log(RH/100);
  return (b*α)/(a-α);
}

function calcTw(T,RH){
  if(isNaN(T)||isNaN(RH)) return NaN;
  return T*Math.atan(0.151977*Math.sqrt(RH+8.313659))
       + Math.atan(T+RH)
       - Math.atan(RH-1.676331)
       + 0.00391838*Math.pow(RH,1.5)*Math.atan(0.023101*RH)
       - 4.686035;
}

// ==========================
// 色
// ==========================
function tempColor(v){
  if(v >= 2) return "#ffb6c1"; // ピンク
  if(v >= 0) return "#ffffff"; // 白
  return "#add8e6";            // 水色
}

function windColor(ws){
  if(ws < 3) return "#ffffff";
  if(ws < 6) return "#0000ff";
  if(ws < 8) return "#ffff00";
  if(ws <10) return "#ff9900";
  return "#ff0000";
}

// ==========================
// AMeDAS 時刻探索
// ==========================
async function getLatestAMeDAS(){
  let d = new Date();
  d.setSeconds(0); d.setMilliseconds(0);
  d.setMinutes(Math.floor(d.getMinutes()/10)*10);

  for(let i=0;i<12;i++){
    const ts =
      d.getFullYear().toString().padStart(4,"0")+
      (d.getMonth()+1).toString().padStart(2,"0")+
      d.getDate().toString().padStart(2,"0")+
      d.getHours().toString().padStart(2,"0")+
      d.getMinutes().toString().padStart(2,"0")+"00";

    try{
      const r = await fetch(
        `https://www.jma.go.jp/bosai/amedas/data/map/${ts}.json`
      );
      if(r.ok) return await r.json();
    }catch{}
    d.setMinutes(d.getMinutes()-10);
  }
  return null;
}

// ==========================
// 雨雲（UTC）
// ==========================
async function updateRainLayer(){
  try{
    const r = await fetch(
      "https://www.jma.go.jp/bosai/jmatile/data/nowc/targetTimes_N1.json"
    );
    if(!r.ok) return;

    const arr = await r.json();
    if(!arr || arr.length===0) return;

    const t = arr[0]; // 最新
    const url =
      `https://www.jma.go.jp/bosai/jmatile/data/nowc/`+
      `${t.basetime}/none/${t.validtime}/surf/hrpns/{z}/{x}/{y}.png`;

    if(rainLayer) map.removeLayer(rainLayer);

    rainLayer = L.tileLayer(url,{
      opacity:0.5,
      maxZoom:16
    }).addTo(map);

  }catch(e){
    console.warn("Rain layer error",e);
  }
}

// ==========================
// 描画
// ==========================
async function draw(){
  layer.clearLayers();

  const table = await fetch(
    "https://www.jma.go.jp/bosai/amedas/const/amedastable.json"
  ).then(r=>r.json());

  const obs = await getLatestAMeDAS();
  if(!obs) return;

  for(const id in obs){
    if(!table[id]) continue;

    const lat = table[id].lat[0] + table[id].lat[1]/60;
    const lon = table[id].lon[0] + table[id].lon[1]/60;

    if(lat<KANTO.latMin||lat>KANTO.latMax||
       lon<KANTO.lonMin||lon>KANTO.lonMax) continue;

    const d = obs[id];
    const T  =(d.temp&&d.temp[1]==0)?d.temp[0]:NaN;
    const RH =(d.humidity&&d.humidity[1]==0)?d.humidity[0]:NaN;
    const Wd =(d.windDirection&&d.windDirection[1]==0)?d.windDirection[0]:NaN;
    const Ws =(d.wind&&d.wind[1]==0)?d.wind[0]:NaN;

    let val=T, unit="℃";
    if(DispElem==="tw") val=calcTw(T,RH);
    if(DispElem==="td") val=calcTd(T,RH);
    if(DispElem==="rh"){ val=RH; unit="%"; }

    if(!isNaN(val)){
      const html =
        `<span class="valbox" style="background:${tempColor(val)}">
          ${val.toFixed(1)}${unit}
        </span>`;
      L.marker([lat,lon],{
        icon:L.divIcon({html,className:""})
      }).addTo(layer);
    }

    // 風矢印
    if(!isNaN(Wd)&&!isNaN(Ws)){
      const ang=(Wd*22.5-90)*Math.PI/180;
      const len=0.18;
      L.polyline([
        [lat,lon],
        [lat+len*Math.cos(ang), lon+len*Math.sin(ang)]
      ],{
        color:windColor(Ws),
        weight:2
      }).addTo(layer);
    }
  }
}

// ==========================
// UI
// ==========================
document.querySelectorAll('input[name="elem"]').forEach(r=>{
  r.onchange=()=>{ DispElem=r.value; draw(); };
});

// 初期化
draw();
updateRainLayer();

// 更新
setInterval(draw,600000);
setInterval(updateRainLayer,300000);
</script>
</body>
</html>
